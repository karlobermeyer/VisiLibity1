<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VisiLibity v1 Source Code: VisiLibity Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">VisiLibity v1 Source Code<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">VisiLibity Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespace_visi_libity.html" title="VisiLibity&#39;s sole namespace.">VisiLibity</a>'s sole namespace.  
<a href="namespace_visi_libity.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_angle.html">Angle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">angle in radians represented by a value in the interval [0,2*M_PI]  <a href="class_visi_libity_1_1_angle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_visi_libity_1_1_bounding___box.html">Bounding_Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">rectangle with sides parallel to the x- and y-axes  <a href="struct_visi_libity_1_1_bounding___box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_environment.html">Environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">environment represented by simple polygonal outer boundary with simple polygonal holes  <a href="class_visi_libity_1_1_environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_guards.html">Guards</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">set of <a class="el" href="class_visi_libity_1_1_guards.html" title="set of Guards represented by a list of Points">Guards</a> represented by a list of Points  <a href="class_visi_libity_1_1_guards.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">line segment in the plane represented by its endpoints  <a href="class_visi_libity_1_1_line___segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> in the plane represented by Cartesian coordinates.  <a href="class_visi_libity_1_1_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> in the plane packaged together with polar coordinates w.r.t. specified origin.  <a href="class_visi_libity_1_1_polar___point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple polygon in the plane represented by list of vertices  <a href="class_visi_libity_1_1_polygon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">oriented polyline in the plane represented by list of vertices  <a href="class_visi_libity_1_1_polyline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_ray.html">Ray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ray in the plane represented by base <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and bearing <a class="el" href="class_visi_libity_1_1_angle.html" title="angle in radians represented by a value in the interval [0,2*M_PI]">Angle</a>  <a href="class_visi_libity_1_1_ray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_shortest___path___test.html">Shortest_Path_Test</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for writing shortest path <a class="el" href="namespace_visi_libity.html" title="VisiLibity&#39;s sole namespace.">VisiLibity</a> unit tests.  <a href="class_visi_libity_1_1_shortest___path___test.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_unit___test.html">Unit_Test</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for writing <a class="el" href="namespace_visi_libity.html" title="VisiLibity&#39;s sole namespace.">VisiLibity</a> unit tests.  <a href="class_visi_libity_1_1_unit___test.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_visibility___graph.html">Visibility_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">visibility graph of points in an <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes">Environment</a>, represented by adjacency matrix  <a href="class_visi_libity_1_1_visibility___graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_visibility___polygon.html">Visibility_Polygon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">visibility polygon of a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> in an <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes">Environment</a> or <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>  <a href="class_visi_libity_1_1_visibility___polygon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae83e7a472af84e482d88ab9963401fcd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ae83e7a472af84e482d88ab9963401fcd">uniform_random_sample</a> (double lower_bound, double upper_bound)</td></tr>
<tr class="memdesc:ae83e7a472af84e482d88ab9963401fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a uniform random sample from an (inclusive) interval on the real line  <a href="namespace_visi_libity.html#ae83e7a472af84e482d88ab9963401fcd">More...</a><br /></td></tr>
<tr class="separator:ae83e7a472af84e482d88ab9963401fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ddd2a438319145ae0d98553e5631e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a38ddd2a438319145ae0d98553e5631e2">operator==</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a38ddd2a438319145ae0d98553e5631e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff Points' coordinates are identical.  <a href="namespace_visi_libity.html#a38ddd2a438319145ae0d98553e5631e2">More...</a><br /></td></tr>
<tr class="separator:a38ddd2a438319145ae0d98553e5631e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15188ee9a68b8aef4e039adc13dc31be"><td class="memItemLeft" align="right" valign="top"><a id="a15188ee9a68b8aef4e039adc13dc31be" name="a15188ee9a68b8aef4e039adc13dc31be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a15188ee9a68b8aef4e039adc13dc31be"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff Points' coordinates are not identical. <br /></td></tr>
<tr class="separator:a15188ee9a68b8aef4e039adc13dc31be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7c17ac562ca46ac0a5cb365209a35e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a2d7c17ac562ca46ac0a5cb365209a35e">operator&lt;</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a2d7c17ac562ca46ac0a5cb365209a35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare lexicographic order of points  <a href="namespace_visi_libity.html#a2d7c17ac562ca46ac0a5cb365209a35e">More...</a><br /></td></tr>
<tr class="separator:a2d7c17ac562ca46ac0a5cb365209a35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7058b06639d3231e9430b7946c83390c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a7058b06639d3231e9430b7946c83390c">operator&gt;</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a7058b06639d3231e9430b7946c83390c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare lexicographic order of points  <a href="namespace_visi_libity.html#a7058b06639d3231e9430b7946c83390c">More...</a><br /></td></tr>
<tr class="separator:a7058b06639d3231e9430b7946c83390c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0266fe487ca62b657cca017ba5e3b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#aab0266fe487ca62b657cca017ba5e3b2">operator&gt;=</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:aab0266fe487ca62b657cca017ba5e3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare lexicographic order of points  <a href="namespace_visi_libity.html#aab0266fe487ca62b657cca017ba5e3b2">More...</a><br /></td></tr>
<tr class="separator:aab0266fe487ca62b657cca017ba5e3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d3c16417e76f558562c4cea2d7fcb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a48d3c16417e76f558562c4cea2d7fcb5">operator&lt;=</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a48d3c16417e76f558562c4cea2d7fcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare lexicographic order of points  <a href="namespace_visi_libity.html#a48d3c16417e76f558562c4cea2d7fcb5">More...</a><br /></td></tr>
<tr class="separator:a48d3c16417e76f558562c4cea2d7fcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69525459d29f1a3f658c65d08a8c5cf"><td class="memItemLeft" align="right" valign="top"><a id="ae69525459d29f1a3f658c65d08a8c5cf" name="ae69525459d29f1a3f658c65d08a8c5cf"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:ae69525459d29f1a3f658c65d08a8c5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector addition of Points <br /></td></tr>
<tr class="separator:ae69525459d29f1a3f658c65d08a8c5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b36aa58281fdee246455a2f5065c8"><td class="memItemLeft" align="right" valign="top"><a id="a504b36aa58281fdee246455a2f5065c8" name="a504b36aa58281fdee246455a2f5065c8"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a504b36aa58281fdee246455a2f5065c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector subtraction of Points <br /></td></tr>
<tr class="separator:a504b36aa58281fdee246455a2f5065c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ac89fa59679dca49c460fc9f8eacb0"><td class="memItemLeft" align="right" valign="top"><a id="aa0ac89fa59679dca49c460fc9f8eacb0" name="aa0ac89fa59679dca49c460fc9f8eacb0"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="separator:aa0ac89fa59679dca49c460fc9f8eacb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d73049e06ea431337f8fb4b6e4a6fc"><td class="memItemLeft" align="right" valign="top"><a id="a14d73049e06ea431337f8fb4b6e4a6fc" name="a14d73049e06ea431337f8fb4b6e4a6fc"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double scalar, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a14d73049e06ea431337f8fb4b6e4a6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple scaling treats the <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> as a vector <br /></td></tr>
<tr class="separator:a14d73049e06ea431337f8fb4b6e4a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af817ae9a4ab063c3808aa0de8aaa77"><td class="memItemLeft" align="right" valign="top"><a id="a9af817ae9a4ab063c3808aa0de8aaa77" name="a9af817ae9a4ab063c3808aa0de8aaa77"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, double scalar)</td></tr>
<tr class="memdesc:a9af817ae9a4ab063c3808aa0de8aaa77"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple scaling treats the <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> as a vector <br /></td></tr>
<tr class="separator:a9af817ae9a4ab063c3808aa0de8aaa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa67943ca3ec83270991e0aba4d4000a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#aaa67943ca3ec83270991e0aba4d4000a">cross</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:aaa67943ca3ec83270991e0aba4d4000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">cross product (signed) magnitude treats the Points as vectors  <a href="namespace_visi_libity.html#aaa67943ca3ec83270991e0aba4d4000a">More...</a><br /></td></tr>
<tr class="separator:aaa67943ca3ec83270991e0aba4d4000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c4ba38875fb632ee9d0237f77f615a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#af8c4ba38875fb632ee9d0237f77f615a">distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:af8c4ba38875fb632ee9d0237f77f615a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between Points.  <a href="namespace_visi_libity.html#af8c4ba38875fb632ee9d0237f77f615a">More...</a><br /></td></tr>
<tr class="separator:af8c4ba38875fb632ee9d0237f77f615a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dbebc53067af9f445b0cee233a43e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ad2dbebc53067af9f445b0cee233a43e0">distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp)</td></tr>
<tr class="memdesc:ad2dbebc53067af9f445b0cee233a43e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a>.  <a href="namespace_visi_libity.html#ad2dbebc53067af9f445b0cee233a43e0">More...</a><br /></td></tr>
<tr class="separator:ad2dbebc53067af9f445b0cee233a43e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3dfdcc362e74b9e093710f42ed29b8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a9e3dfdcc362e74b9e093710f42ed29b8">distance</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a9e3dfdcc362e74b9e093710f42ed29b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a>.  <a href="namespace_visi_libity.html#a9e3dfdcc362e74b9e093710f42ed29b8">More...</a><br /></td></tr>
<tr class="separator:a9e3dfdcc362e74b9e093710f42ed29b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a811b3c6e641a765fa562c1b235b0ef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a2a811b3c6e641a765fa562c1b235b0ef">distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray_temp)</td></tr>
<tr class="memdesc:a2a811b3c6e641a765fa562c1b235b0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>.  <a href="namespace_visi_libity.html#a2a811b3c6e641a765fa562c1b235b0ef">More...</a><br /></td></tr>
<tr class="separator:a2a811b3c6e641a765fa562c1b235b0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f24c03b2d19e0db2d590b45deffd2e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a87f24c03b2d19e0db2d590b45deffd2e">distance</a> (const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a87f24c03b2d19e0db2d590b45deffd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>.  <a href="namespace_visi_libity.html#a87f24c03b2d19e0db2d590b45deffd2e">More...</a><br /></td></tr>
<tr class="separator:a87f24c03b2d19e0db2d590b45deffd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5563dc03c315a394d8180444af7ce1b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a5563dc03c315a394d8180444af7ce1b0">distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;polyline_temp)</td></tr>
<tr class="memdesc:a5563dc03c315a394d8180444af7ce1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices">Polyline</a>.  <a href="namespace_visi_libity.html#a5563dc03c315a394d8180444af7ce1b0">More...</a><br /></td></tr>
<tr class="separator:a5563dc03c315a394d8180444af7ce1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742bb08e30a47138140a0ff33fa7c9e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a742bb08e30a47138140a0ff33fa7c9e0">distance</a> (const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;polyline_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a742bb08e30a47138140a0ff33fa7c9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices">Polyline</a>.  <a href="namespace_visi_libity.html#a742bb08e30a47138140a0ff33fa7c9e0">More...</a><br /></td></tr>
<tr class="separator:a742bb08e30a47138140a0ff33fa7c9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983515dbb1d297fc2b190fa8d8925d5c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a983515dbb1d297fc2b190fa8d8925d5c">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon_temp)</td></tr>
<tr class="memdesc:a983515dbb1d297fc2b190fa8d8925d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>'s boundary.  <a href="namespace_visi_libity.html#a983515dbb1d297fc2b190fa8d8925d5c">More...</a><br /></td></tr>
<tr class="separator:a983515dbb1d297fc2b190fa8d8925d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a101b4f71120c5e30a1b50b2ce5b3e9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a9a101b4f71120c5e30a1b50b2ce5b3e9">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a9a101b4f71120c5e30a1b50b2ce5b3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>'s boundary.  <a href="namespace_visi_libity.html#a9a101b4f71120c5e30a1b50b2ce5b3e9">More...</a><br /></td></tr>
<tr class="separator:a9a101b4f71120c5e30a1b50b2ce5b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49beee9427a282c7fa9b26248bb8feb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ac49beee9427a282c7fa9b26248bb8feb">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;environment_temp)</td></tr>
<tr class="memdesc:ac49beee9427a282c7fa9b26248bb8feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes">Environment</a>'s boundary.  <a href="namespace_visi_libity.html#ac49beee9427a282c7fa9b26248bb8feb">More...</a><br /></td></tr>
<tr class="separator:ac49beee9427a282c7fa9b26248bb8feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9731b17ed285d5b937aa49f0e676a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a1a9731b17ed285d5b937aa49f0e676a3">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;environment_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a1a9731b17ed285d5b937aa49f0e676a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes">Environment</a>'s boundary.  <a href="namespace_visi_libity.html#a1a9731b17ed285d5b937aa49f0e676a3">More...</a><br /></td></tr>
<tr class="separator:a1a9731b17ed285d5b937aa49f0e676a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe9be2353f10d88512c5bd70ccdb95b"><td class="memItemLeft" align="right" valign="top"><a id="aefe9be2353f10d88512c5bd70ccdb95b" name="aefe9be2353f10d88512c5bd70ccdb95b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:aefe9be2353f10d88512c5bd70ccdb95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> <br /></td></tr>
<tr class="separator:aefe9be2353f10d88512c5bd70ccdb95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291c052b8939fccc3f35b75950885656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a291c052b8939fccc3f35b75950885656">operator==</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2)</td></tr>
<tr class="memdesc:a291c052b8939fccc3f35b75950885656"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff endpoint coordinates are exactly equal, but false if either <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> has size 0  <a href="namespace_visi_libity.html#a291c052b8939fccc3f35b75950885656">More...</a><br /></td></tr>
<tr class="separator:a291c052b8939fccc3f35b75950885656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee21c531f73f2fe7f1ec709c6b624b4"><td class="memItemLeft" align="right" valign="top"><a id="a6ee21c531f73f2fe7f1ec709c6b624b4" name="a6ee21c531f73f2fe7f1ec709c6b624b4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2)</td></tr>
<tr class="memdesc:a6ee21c531f73f2fe7f1ec709c6b624b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff endpoint coordinates are not == <br /></td></tr>
<tr class="separator:a6ee21c531f73f2fe7f1ec709c6b624b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63fae6bd727b4fb438bd0808b9b9eb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ab63fae6bd727b4fb438bd0808b9b9eb2">equivalent</a> (<a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> line_segment1, <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> line_segment2, double epsilon=0)</td></tr>
<tr class="memdesc:ab63fae6bd727b4fb438bd0808b9b9eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff line segments' endpoints match up w/in a (closed) <em>epsilon</em> ball of each other, but false if either <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> has size 0  <a href="namespace_visi_libity.html#ab63fae6bd727b4fb438bd0808b9b9eb2">More...</a><br /></td></tr>
<tr class="separator:ab63fae6bd727b4fb438bd0808b9b9eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b882c36565453f1f3627b530cf40c4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a80b882c36565453f1f3627b530cf40c4">distance</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2)</td></tr>
<tr class="memdesc:a80b882c36565453f1f3627b530cf40c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between Line_Segments.  <a href="namespace_visi_libity.html#a80b882c36565453f1f3627b530cf40c4">More...</a><br /></td></tr>
<tr class="separator:a80b882c36565453f1f3627b530cf40c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dae697df9347a8328d86926d294ed02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a1dae697df9347a8328d86926d294ed02">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment, const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon)</td></tr>
<tr class="memdesc:a1dae697df9347a8328d86926d294ed02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> and the boundary of a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>.  <a href="namespace_visi_libity.html#a1dae697df9347a8328d86926d294ed02">More...</a><br /></td></tr>
<tr class="separator:a1dae697df9347a8328d86926d294ed02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccb6ad5efaaf65da0adefc86111fb5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a7ccb6ad5efaaf65da0adefc86111fb5b">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment)</td></tr>
<tr class="memdesc:a7ccb6ad5efaaf65da0adefc86111fb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> and the boundary of a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>.  <a href="namespace_visi_libity.html#a7ccb6ad5efaaf65da0adefc86111fb5b">More...</a><br /></td></tr>
<tr class="separator:a7ccb6ad5efaaf65da0adefc86111fb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa0ac73a3d3250473614f4332c3f772"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#acfa0ac73a3d3250473614f4332c3f772">intersect</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2, double epsilon=0.0)</td></tr>
<tr class="memdesc:acfa0ac73a3d3250473614f4332c3f772"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff the Euclidean distance between Line_Segments is no greater than <em>epsilon</em>, false if either line segment has size 0  <a href="namespace_visi_libity.html#acfa0ac73a3d3250473614f4332c3f772">More...</a><br /></td></tr>
<tr class="separator:acfa0ac73a3d3250473614f4332c3f772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8551551fe3ae479755b02342b3f3cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a4b8551551fe3ae479755b02342b3f3cd">intersect_proper</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2, double epsilon=0.0)</td></tr>
<tr class="memdesc:a4b8551551fe3ae479755b02342b3f3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff line segments intersect properly w/in epsilon, false if either line segment has size 0  <a href="namespace_visi_libity.html#a4b8551551fe3ae479755b02342b3f3cd">More...</a><br /></td></tr>
<tr class="separator:a4b8551551fe3ae479755b02342b3f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab815eaf17c3790348f229b63b2130b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#acab815eaf17c3790348f229b63b2130b">intersection</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2, double epsilon=0.0)</td></tr>
<tr class="memdesc:acab815eaf17c3790348f229b63b2130b"><td class="mdescLeft">&#160;</td><td class="mdescRight">intersection of Line_Segments  <a href="namespace_visi_libity.html#acab815eaf17c3790348f229b63b2130b">More...</a><br /></td></tr>
<tr class="separator:acab815eaf17c3790348f229b63b2130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e06c0dc7b2751c2e8dabfeb155745"><td class="memItemLeft" align="right" valign="top"><a id="aa73e06c0dc7b2751c2e8dabfeb155745" name="aa73e06c0dc7b2751c2e8dabfeb155745"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp)</td></tr>
<tr class="memdesc:aa73e06c0dc7b2751c2e8dabfeb155745"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> <br /></td></tr>
<tr class="separator:aa73e06c0dc7b2751c2e8dabfeb155745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1cb3a74ef6cea43ac9f9e2cc5af97a"><td class="memItemLeft" align="right" valign="top"><a id="a5e1cb3a74ef6cea43ac9f9e2cc5af97a" name="a5e1cb3a74ef6cea43ac9f9e2cc5af97a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a5e1cb3a74ef6cea43ac9f9e2cc5af97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:a5e1cb3a74ef6cea43ac9f9e2cc5af97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91da0d86f4bc8d5c858128261344f42"><td class="memItemLeft" align="right" valign="top"><a id="ab91da0d86f4bc8d5c858128261344f42" name="ab91da0d86f4bc8d5c858128261344f42"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:ab91da0d86f4bc8d5c858128261344f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:ab91da0d86f4bc8d5c858128261344f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5461d875fd043baf6ed0c06a2e8f45d"><td class="memItemLeft" align="right" valign="top"><a id="ac5461d875fd043baf6ed0c06a2e8f45d" name="ac5461d875fd043baf6ed0c06a2e8f45d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:ac5461d875fd043baf6ed0c06a2e8f45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:ac5461d875fd043baf6ed0c06a2e8f45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5460b410d9a16cdc1bf2e1bc396a1f13"><td class="memItemLeft" align="right" valign="top"><a id="a5460b410d9a16cdc1bf2e1bc396a1f13" name="a5460b410d9a16cdc1bf2e1bc396a1f13"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a5460b410d9a16cdc1bf2e1bc396a1f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:a5460b410d9a16cdc1bf2e1bc396a1f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b8407f54ddae6381c47064a2230b6c"><td class="memItemLeft" align="right" valign="top"><a id="a88b8407f54ddae6381c47064a2230b6c" name="a88b8407f54ddae6381c47064a2230b6c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a88b8407f54ddae6381c47064a2230b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:a88b8407f54ddae6381c47064a2230b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f81e7fd8afa84cbc9e7f59b35f5af6"><td class="memItemLeft" align="right" valign="top"><a id="a58f81e7fd8afa84cbc9e7f59b35f5af6" name="a58f81e7fd8afa84cbc9e7f59b35f5af6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a58f81e7fd8afa84cbc9e7f59b35f5af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:a58f81e7fd8afa84cbc9e7f59b35f5af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88995c5a50c9b6c94c50f1c37a384f5"><td class="memItemLeft" align="right" valign="top"><a id="ae88995c5a50c9b6c94c50f1c37a384f5" name="ae88995c5a50c9b6c94c50f1c37a384f5"></a>
<a class="el" href="class_visi_libity_1_1_angle.html">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:ae88995c5a50c9b6c94c50f1c37a384f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add angles' radians and mod into [0, 2*M_PI) <br /></td></tr>
<tr class="separator:ae88995c5a50c9b6c94c50f1c37a384f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bde1742747b574d5619553d63beb69"><td class="memItemLeft" align="right" valign="top"><a id="a00bde1742747b574d5619553d63beb69" name="a00bde1742747b574d5619553d63beb69"></a>
<a class="el" href="class_visi_libity_1_1_angle.html">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a00bde1742747b574d5619553d63beb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract angles' radians and mod into [0, 2*M_PI) <br /></td></tr>
<tr class="separator:a00bde1742747b574d5619553d63beb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54c3c29b782a7bcaaf80df7c870bbfb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ab54c3c29b782a7bcaaf80df7c870bbfb">geodesic_distance</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:ab54c3c29b782a7bcaaf80df7c870bbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">geodesic distance in radians between Angles  <a href="namespace_visi_libity.html#ab54c3c29b782a7bcaaf80df7c870bbfb">More...</a><br /></td></tr>
<tr class="separator:ab54c3c29b782a7bcaaf80df7c870bbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d98628c28fc4ae2e2ca9a47b341c673"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a6d98628c28fc4ae2e2ca9a47b341c673">geodesic_direction</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a6d98628c28fc4ae2e2ca9a47b341c673"><td class="mdescLeft">&#160;</td><td class="mdescRight">1.0 =&gt; geodesic path from angle1 to angle2 is couterclockwise, -1.0 =&gt; clockwise  <a href="namespace_visi_libity.html#a6d98628c28fc4ae2e2ca9a47b341c673">More...</a><br /></td></tr>
<tr class="separator:a6d98628c28fc4ae2e2ca9a47b341c673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24b75a9754489bae1b26b543e3264d5"><td class="memItemLeft" align="right" valign="top"><a id="ad24b75a9754489bae1b26b543e3264d5" name="ad24b75a9754489bae1b26b543e3264d5"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle_temp)</td></tr>
<tr class="memdesc:ad24b75a9754489bae1b26b543e3264d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">print <a class="el" href="class_visi_libity_1_1_angle.html" title="angle in radians represented by a value in the interval [0,2*M_PI]">Angle</a> <br /></td></tr>
<tr class="separator:ad24b75a9754489bae1b26b543e3264d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149518e70a1a5fcde96173d7d3fb9f9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a149518e70a1a5fcde96173d7d3fb9f9f">operator==</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:a149518e70a1a5fcde96173d7d3fb9f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare member data  <a href="namespace_visi_libity.html#a149518e70a1a5fcde96173d7d3fb9f9f">More...</a><br /></td></tr>
<tr class="separator:a149518e70a1a5fcde96173d7d3fb9f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cdaff47e746e8f577ef051ffe1c63a"><td class="memItemLeft" align="right" valign="top"><a id="af1cdaff47e746e8f577ef051ffe1c63a" name="af1cdaff47e746e8f577ef051ffe1c63a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="separator:af1cdaff47e746e8f577ef051ffe1c63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac507aa8babe8577aa58a90fff0f3a1ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ac507aa8babe8577aa58a90fff0f3a1ed">operator&gt;</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:ac507aa8babe8577aa58a90fff0f3a1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare according to polar lexicographic order (smaller bearing, then smaller range)  <a href="namespace_visi_libity.html#ac507aa8babe8577aa58a90fff0f3a1ed">More...</a><br /></td></tr>
<tr class="separator:ac507aa8babe8577aa58a90fff0f3a1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9d951f84a0a01186899f00ce2eb24f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a7b9d951f84a0a01186899f00ce2eb24f">operator&lt;</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:a7b9d951f84a0a01186899f00ce2eb24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare according to polar lexicographic order (smaller bearing, then smaller range)  <a href="namespace_visi_libity.html#a7b9d951f84a0a01186899f00ce2eb24f">More...</a><br /></td></tr>
<tr class="separator:a7b9d951f84a0a01186899f00ce2eb24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87a4a15e00ffdfe72fbb2b56d4020a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ac87a4a15e00ffdfe72fbb2b56d4020a3">operator&gt;=</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:ac87a4a15e00ffdfe72fbb2b56d4020a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare according to polar lexicographic order (smaller bearing, then smaller range)  <a href="namespace_visi_libity.html#ac87a4a15e00ffdfe72fbb2b56d4020a3">More...</a><br /></td></tr>
<tr class="separator:ac87a4a15e00ffdfe72fbb2b56d4020a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083b69c4720e5cd817d7703c6e74faf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a083b69c4720e5cd817d7703c6e74faf2">operator&lt;=</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:a083b69c4720e5cd817d7703c6e74faf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare according to polar lexicographic order (smaller bearing, then smaller range)  <a href="namespace_visi_libity.html#a083b69c4720e5cd817d7703c6e74faf2">More...</a><br /></td></tr>
<tr class="separator:a083b69c4720e5cd817d7703c6e74faf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed442d343a0cff676f732943ef189ab"><td class="memItemLeft" align="right" valign="top"><a id="a8ed442d343a0cff676f732943ef189ab" name="a8ed442d343a0cff676f732943ef189ab"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point_temp)</td></tr>
<tr class="memdesc:a8ed442d343a0cff676f732943ef189ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">print <a class="el" href="class_visi_libity_1_1_polar___point.html" title="Point in the plane packaged together with polar coordinates w.r.t. specified origin.">Polar_Point</a> <br /></td></tr>
<tr class="separator:a8ed442d343a0cff676f732943ef189ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ecb7431af376e585b58df6f10235a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#aa5ecb7431af376e585b58df6f10235a7">operator==</a> (const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray1, const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray2)</td></tr>
<tr class="memdesc:aa5ecb7431af376e585b58df6f10235a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare member data  <a href="namespace_visi_libity.html#aa5ecb7431af376e585b58df6f10235a7">More...</a><br /></td></tr>
<tr class="separator:aa5ecb7431af376e585b58df6f10235a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c9ca72e0e00a3343959b089c8a0442"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ad1c9ca72e0e00a3343959b089c8a0442">operator!=</a> (const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray1, const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray2)</td></tr>
<tr class="memdesc:ad1c9ca72e0e00a3343959b089c8a0442"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare member data  <a href="namespace_visi_libity.html#ad1c9ca72e0e00a3343959b089c8a0442">More...</a><br /></td></tr>
<tr class="separator:ad1c9ca72e0e00a3343959b089c8a0442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc9dcdaa19f0eb9b9e1eca41b88bdb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#abdc9dcdaa19f0eb9b9e1eca41b88bdb0">intersection</a> (const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> ray_temp, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp, double epsilon=0.0)</td></tr>
<tr class="memdesc:abdc9dcdaa19f0eb9b9e1eca41b88bdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the intersection of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> with a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>  <a href="namespace_visi_libity.html#abdc9dcdaa19f0eb9b9e1eca41b88bdb0">More...</a><br /></td></tr>
<tr class="separator:abdc9dcdaa19f0eb9b9e1eca41b88bdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5acd48758cf845aa95e8520b7ad923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a5b5acd48758cf845aa95e8520b7ad923">intersection</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp, const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray_temp, double epsilon=0.0)</td></tr>
<tr class="memdesc:a5b5acd48758cf845aa95e8520b7ad923"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the intersection of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> with a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>  <a href="namespace_visi_libity.html#a5b5acd48758cf845aa95e8520b7ad923">More...</a><br /></td></tr>
<tr class="separator:a5b5acd48758cf845aa95e8520b7ad923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ec75acc21d42014d5dd7a7c11c93d3"><td class="memItemLeft" align="right" valign="top"><a id="a94ec75acc21d42014d5dd7a7c11c93d3" name="a94ec75acc21d42014d5dd7a7c11c93d3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;polyline_temp)</td></tr>
<tr class="separator:a94ec75acc21d42014d5dd7a7c11c93d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96076229fbc5ad8d484428bee92b153"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ac96076229fbc5ad8d484428bee92b153">operator==</a> (<a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon1, <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon2)</td></tr>
<tr class="memdesc:ac96076229fbc5ad8d484428bee92b153"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff vertex lists are identical, but false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a> has size 0  <a href="namespace_visi_libity.html#ac96076229fbc5ad8d484428bee92b153">More...</a><br /></td></tr>
<tr class="separator:ac96076229fbc5ad8d484428bee92b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f88b241ecd276c15af5cd8b9edd7a6c"><td class="memItemLeft" align="right" valign="top"><a id="a9f88b241ecd276c15af5cd8b9edd7a6c" name="a9f88b241ecd276c15af5cd8b9edd7a6c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon1, <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon2)</td></tr>
<tr class="separator:a9f88b241ecd276c15af5cd8b9edd7a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea3cfda0e212765b7b3bc69d46f7b2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a8ea3cfda0e212765b7b3bc69d46f7b2f">equivalent</a> (<a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon1, <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon2, double epsilon=0.0)</td></tr>
<tr class="memdesc:a8ea3cfda0e212765b7b3bc69d46f7b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff the <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>'s vertices match up w/in a (closed) epsilon ball of each other, but false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a> has size 0  <a href="namespace_visi_libity.html#a8ea3cfda0e212765b7b3bc69d46f7b2f">More...</a><br /></td></tr>
<tr class="separator:a8ea3cfda0e212765b7b3bc69d46f7b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dca7869e72683bc8a661a5e7553474"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a38dca7869e72683bc8a661a5e7553474">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon1, const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon2)</td></tr>
<tr class="memdesc:a38dca7869e72683bc8a661a5e7553474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between Polygons' boundaries.  <a href="namespace_visi_libity.html#a38dca7869e72683bc8a661a5e7553474">More...</a><br /></td></tr>
<tr class="separator:a38dca7869e72683bc8a661a5e7553474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af913bacb6d219145c8d458e67f1de91e"><td class="memItemLeft" align="right" valign="top"><a id="af913bacb6d219145c8d458e67f1de91e" name="af913bacb6d219145c8d458e67f1de91e"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon_temp)</td></tr>
<tr class="separator:af913bacb6d219145c8d458e67f1de91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9389a3b97d3d5b7aa6819690a100167"><td class="memItemLeft" align="right" valign="top"><a id="ae9389a3b97d3d5b7aa6819690a100167" name="ae9389a3b97d3d5b7aa6819690a100167"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;environment_temp)</td></tr>
<tr class="memdesc:ae9389a3b97d3d5b7aa6819690a100167"><td class="mdescLeft">&#160;</td><td class="mdescRight">printing <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes">Environment</a> <br /></td></tr>
<tr class="separator:ae9389a3b97d3d5b7aa6819690a100167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af106424bac592e29491becd761fdac53"><td class="memItemLeft" align="right" valign="top"><a id="af106424bac592e29491becd761fdac53" name="af106424bac592e29491becd761fdac53"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_guards.html">Guards</a> &amp;guards)</td></tr>
<tr class="memdesc:af106424bac592e29491becd761fdac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">print <a class="el" href="class_visi_libity_1_1_guards.html" title="set of Guards represented by a list of Points">Guards</a> <br /></td></tr>
<tr class="separator:af106424bac592e29491becd761fdac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0683806072e873c2156cb43686ea5b3e"><td class="memItemLeft" align="right" valign="top"><a id="a0683806072e873c2156cb43686ea5b3e" name="a0683806072e873c2156cb43686ea5b3e"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_visibility___graph.html">Visibility_Graph</a> &amp;visibility_graph)</td></tr>
<tr class="memdesc:a0683806072e873c2156cb43686ea5b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">print <a class="el" href="class_visi_libity_1_1_visibility___graph.html" title="visibility graph of points in an Environment, represented by adjacency matrix">Visibility_Graph</a> adjacency matrix <br /></td></tr>
<tr class="separator:a0683806072e873c2156cb43686ea5b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7ac10ccfdc14c4c8093b7528c1fd7fd5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a7ac10ccfdc14c4c8093b7528c1fd7fd5">FIOS_PRECISION</a> = 10</td></tr>
<tr class="memdesc:a7ac10ccfdc14c4c8093b7528c1fd7fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">floating-point display precision.  <a href="namespace_visi_libity.html#a7ac10ccfdc14c4c8093b7528c1fd7fd5">More...</a><br /></td></tr>
<tr class="separator:a7ac10ccfdc14c4c8093b7528c1fd7fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="namespace_visi_libity.html" title="VisiLibity&#39;s sole namespace.">VisiLibity</a>'s sole namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1a9731b17ed285d5b937aa49f0e676a3" name="a1a9731b17ed285d5b937aa49f0e676a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9731b17ed285d5b937aa49f0e676a3">&#9670;&#160;</a></span>boundary_distance() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>environment_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes">Environment</a>'s boundary. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes">Environment</a> is nonempty </dd></dl>

</div>
</div>
<a id="a1dae697df9347a8328d86926d294ed02" name="a1dae697df9347a8328d86926d294ed02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dae697df9347a8328d86926d294ed02">&#9670;&#160;</a></span>boundary_distance() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> and the boundary of a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>line_segment.size()</em> &gt; 0 and <em>polygon.n()</em> &gt; 0 </dd></dl>

</div>
</div>
<a id="ac49beee9427a282c7fa9b26248bb8feb" name="ac49beee9427a282c7fa9b26248bb8feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49beee9427a282c7fa9b26248bb8feb">&#9670;&#160;</a></span>boundary_distance() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>environment_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes">Environment</a>'s boundary. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes">Environment</a> is nonempty </dd></dl>

</div>
</div>
<a id="a983515dbb1d297fc2b190fa8d8925d5c" name="a983515dbb1d297fc2b190fa8d8925d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983515dbb1d297fc2b190fa8d8925d5c">&#9670;&#160;</a></span>boundary_distance() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>'s boundary. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a> is nonempty </dd></dl>

</div>
</div>
<a id="a7ccb6ad5efaaf65da0adefc86111fb5b" name="a7ccb6ad5efaaf65da0adefc86111fb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccb6ad5efaaf65da0adefc86111fb5b">&#9670;&#160;</a></span>boundary_distance() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> and the boundary of a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>line_segment.size()</em> &gt; 0 and <em>polygon.n()</em> &gt; 0 </dd></dl>

</div>
</div>
<a id="a38dca7869e72683bc8a661a5e7553474" name="a38dca7869e72683bc8a661a5e7553474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dca7869e72683bc8a661a5e7553474">&#9670;&#160;</a></span>boundary_distance() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between Polygons' boundaries. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>polygon1</em> and <em>polygon2</em> each have greater than 0 vertices </dd></dl>

</div>
</div>
<a id="a9a101b4f71120c5e30a1b50b2ce5b3e9" name="a9a101b4f71120c5e30a1b50b2ce5b3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a101b4f71120c5e30a1b50b2ce5b3e9">&#9670;&#160;</a></span>boundary_distance() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>'s boundary. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a> is nonempty </dd></dl>

</div>
</div>
<a id="aaa67943ca3ec83270991e0aba4d4000a" name="aaa67943ca3ec83270991e0aba4d4000a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa67943ca3ec83270991e0aba4d4000a">&#9670;&#160;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cross product (signed) magnitude treats the Points as vectors </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Points' data are numbers </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is equal to the (signed) area of the parallelogram created by the Points viewed as vectors. </dd></dl>

</div>
</div>
<a id="a80b882c36565453f1f3627b530cf40c4" name="a80b882c36565453f1f3627b530cf40c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b882c36565453f1f3627b530cf40c4">&#9670;&#160;</a></span>distance() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between Line_Segments. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>line_segment1.size()</em> &gt; 0 and <em>line_segment2.size()</em> &gt; 0 </dd></dl>

</div>
</div>
<a id="a9e3dfdcc362e74b9e093710f42ed29b8" name="a9e3dfdcc362e74b9e093710f42ed29b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3dfdcc362e74b9e093710f42ed29b8">&#9670;&#160;</a></span>distance() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> is nonempty </dd></dl>

</div>
</div>
<a id="af8c4ba38875fb632ee9d0237f77f615a" name="af8c4ba38875fb632ee9d0237f77f615a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c4ba38875fb632ee9d0237f77f615a">&#9670;&#160;</a></span>distance() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between Points. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Points' data are numbers </dd></dl>

</div>
</div>
<a id="ad2dbebc53067af9f445b0cee233a43e0" name="ad2dbebc53067af9f445b0cee233a43e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dbebc53067af9f445b0cee233a43e0">&#9670;&#160;</a></span>distance() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> is nonempty </dd></dl>

</div>
</div>
<a id="a5563dc03c315a394d8180444af7ce1b0" name="a5563dc03c315a394d8180444af7ce1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5563dc03c315a394d8180444af7ce1b0">&#9670;&#160;</a></span>distance() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices">Polyline</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices">Polyline</a> is nonempty </dd></dl>

</div>
</div>
<a id="a2a811b3c6e641a765fa562c1b235b0ef" name="a2a811b3c6e641a765fa562c1b235b0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a811b3c6e641a765fa562c1b235b0ef">&#9670;&#160;</a></span>distance() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s and <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>'s data are numbers </dd></dl>

</div>
</div>
<a id="a742bb08e30a47138140a0ff33fa7c9e0" name="a742bb08e30a47138140a0ff33fa7c9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742bb08e30a47138140a0ff33fa7c9e0">&#9670;&#160;</a></span>distance() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices">Polyline</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices">Polyline</a> is nonempty </dd></dl>

</div>
</div>
<a id="a87f24c03b2d19e0db2d590b45deffd2e" name="a87f24c03b2d19e0db2d590b45deffd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f24c03b2d19e0db2d590b45deffd2e">&#9670;&#160;</a></span>distance() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> and a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a>'s and <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>'s data are numbers </dd></dl>

</div>
</div>
<a id="ab63fae6bd727b4fb438bd0808b9b9eb2" name="ab63fae6bd727b4fb438bd0808b9b9eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63fae6bd727b4fb438bd0808b9b9eb2">&#9670;&#160;</a></span>equivalent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td>
          <td class="paramname"><em>line_segment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff line segments' endpoints match up w/in a (closed) <em>epsilon</em> ball of each other, but false if either <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> has size 0 </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>this function will return true even if it has to flip the orientation of one of the segments to get the vertices to match up </dd></dl>

</div>
</div>
<a id="a8ea3cfda0e212765b7b3bc69d46f7b2f" name="a8ea3cfda0e212765b7b3bc69d46f7b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea3cfda0e212765b7b3bc69d46f7b2f">&#9670;&#160;</a></span>equivalent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a>&#160;</td>
          <td class="paramname"><em>polygon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a>&#160;</td>
          <td class="paramname"><em>polygon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff the <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a>'s vertices match up w/in a (closed) epsilon ball of each other, but false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a> has size 0 </p>
<p >Respects number, ordering, and orientation of vertices, i.e., even if the (conceptual) polygons represented by two Polygons are identical, they are not considered <em>epsilon</em> - equivalent unless the number of vertices is the same, the orientations are the same (cw vs. ccw list), and the Points of the vertex lists match up within epsilon. This function does attempt to match the polygons for all possible cyclic permutations, hence the quadratic time complexity. </p><dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>O(n^2) time complexity, where n is the number of vertices representing the polygon </dd></dl>

</div>
</div>
<a id="a6d98628c28fc4ae2e2ca9a47b341c673" name="a6d98628c28fc4ae2e2ca9a47b341c673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d98628c28fc4ae2e2ca9a47b341c673">&#9670;&#160;</a></span>geodesic_direction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::geodesic_direction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>angle2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1.0 =&gt; geodesic path from angle1 to angle2 is couterclockwise, -1.0 =&gt; clockwise </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>angle1</em> and <em>angle2</em> data are numbers </dd></dl>

</div>
</div>
<a id="ab54c3c29b782a7bcaaf80df7c870bbfb" name="ab54c3c29b782a7bcaaf80df7c870bbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54c3c29b782a7bcaaf80df7c870bbfb">&#9670;&#160;</a></span>geodesic_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::geodesic_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>angle2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>geodesic distance in radians between Angles </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>angle1</em> and <em>angle2</em> data are numbers </dd></dl>

</div>
</div>
<a id="acfa0ac73a3d3250473614f4332c3f772" name="acfa0ac73a3d3250473614f4332c3f772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa0ac73a3d3250473614f4332c3f772">&#9670;&#160;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff the Euclidean distance between Line_Segments is no greater than <em>epsilon</em>, false if either line segment has size 0 </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>

</div>
</div>
<a id="a4b8551551fe3ae479755b02342b3f3cd" name="a4b8551551fe3ae479755b02342b3f3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8551551fe3ae479755b02342b3f3cd">&#9670;&#160;</a></span>intersect_proper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::intersect_proper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff line segments intersect properly w/in epsilon, false if either line segment has size 0 </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true iff Line_Segments intersect exactly at a single point in their relative interiors. For robustness, here the relative interior of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> is consider to be any <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates.">Point</a> in the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> which is a distance greater than <em>epsilon</em> from both endpoints. </dd></dl>

</div>
</div>
<a id="acab815eaf17c3790348f229b63b2130b" name="acab815eaf17c3790348f229b63b2130b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab815eaf17c3790348f229b63b2130b">&#9670;&#160;</a></span>intersection() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> VisiLibity::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>intersection of Line_Segments </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> of size 0, 1, or 2 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>size 0 results if the distance (or at least the floating-point computed distance) between line_segment1 and line_segment2 is (strictly) greater than epsilon. size 1 results if the segments intersect properly, form a "T" intersection, or "--"" intersection. size 2 results when two or more endpoints are a Euclidean distance no greater than <em>epsilon</em> from the opposite segment, and the overlap of the segments has a length greater than <em>epsilon</em>. </dd></dl>

</div>
</div>
<a id="a5b5acd48758cf845aa95e8520b7ad923" name="a5b5acd48758cf845aa95e8520b7ad923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5acd48758cf845aa95e8520b7ad923">&#9670;&#160;</a></span>intersection() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> VisiLibity::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the intersection of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> with a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a> </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>member data of <em>ray_temp</em> has been assigned (numbers) and <em>line_segment_temp</em> has size greater than 0 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>as a convention, if the intersection has positive length, the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> returned has the first point closest to the <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>'s base point </dd></dl>

</div>
</div>
<a id="abdc9dcdaa19f0eb9b9e1eca41b88bdb0" name="abdc9dcdaa19f0eb9b9e1eca41b88bdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc9dcdaa19f0eb9b9e1eca41b88bdb0">&#9670;&#160;</a></span>intersection() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> VisiLibity::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a>&#160;</td>
          <td class="paramname"><em>ray_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the intersection of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> with a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a> </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>member data of <em>ray_temp</em> has been assigned (numbers) and <em>line_segment_temp</em> has size greater than 0 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>as a convention, if the intersection has positive length, the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> returned has the first point closest to the <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle">Ray</a>'s base point </dd></dl>

</div>
</div>
<a id="ad1c9ca72e0e00a3343959b089c8a0442" name="ad1c9ca72e0e00a3343959b089c8a0442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c9ca72e0e00a3343959b089c8a0442">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare member data </p>
<dl class="section remark"><dt>Remarks</dt><dd>negation of == </dd></dl>

</div>
</div>
<a id="a2d7c17ac562ca46ac0a5cb365209a35e" name="a2d7c17ac562ca46ac0a5cb365209a35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7c17ac562ca46ac0a5cb365209a35e">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare lexicographic order of points </p>
<p >For Points p1 and p2, p1 &lt; p2 iff either p1.x() &lt; p2.x() or p1.x()==p2.x() and p1.y()&lt;p2.y(). False if any member data have not been assigned (numbers). </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a line parallel to one of the axes </dd></dl>

</div>
</div>
<a id="a7b9d951f84a0a01186899f00ce2eb24f" name="a7b9d951f84a0a01186899f00ce2eb24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9d951f84a0a01186899f00ce2eb24f">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare according to polar lexicographic order (smaller bearing, then smaller range) </p>
<p >false if any member data have not been assigned (numbers) </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a radial line </dd></dl>

</div>
</div>
<a id="a48d3c16417e76f558562c4cea2d7fcb5" name="a48d3c16417e76f558562c4cea2d7fcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d3c16417e76f558562c4cea2d7fcb5">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare lexicographic order of points </p>
<p >For Points p1 and p2, p1 &lt; p2 iff either p1.x() &lt; p2.x() or p1.x()==p2.x() and p1.y()&lt;p2.y(). False if any member data have not been assigned (numbers). </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a line parallel to one of the axes </dd></dl>

</div>
</div>
<a id="a083b69c4720e5cd817d7703c6e74faf2" name="a083b69c4720e5cd817d7703c6e74faf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083b69c4720e5cd817d7703c6e74faf2">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare according to polar lexicographic order (smaller bearing, then smaller range) </p>
<p >false if any member data have not been assigned (numbers) </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a radial line </dd></dl>

</div>
</div>
<a id="a291c052b8939fccc3f35b75950885656" name="a291c052b8939fccc3f35b75950885656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291c052b8939fccc3f35b75950885656">&#9670;&#160;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff endpoint coordinates are exactly equal, but false if either <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints">Line_Segment</a> has size 0 </p>
<dl class="section remark"><dt>Remarks</dt><dd>respects ordering of vertices, i.e., even if the line segments overlap exactly, they are not considered == unless the orientations are the same </dd></dl>

</div>
</div>
<a id="a38ddd2a438319145ae0d98553e5631e2" name="a38ddd2a438319145ae0d98553e5631e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ddd2a438319145ae0d98553e5631e2">&#9670;&#160;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff Points' coordinates are identical. </p>
<dl class="section remark"><dt>Remarks</dt><dd>NAN==NAN returns false, so if either point has not been assigned real number coordinates, they will not be == </dd></dl>

</div>
</div>
<a id="a149518e70a1a5fcde96173d7d3fb9f9f" name="a149518e70a1a5fcde96173d7d3fb9f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149518e70a1a5fcde96173d7d3fb9f9f">&#9670;&#160;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare member data </p>
<dl class="section remark"><dt>Remarks</dt><dd>returns false if any member data are NaN </dd></dl>

</div>
</div>
<a id="aa5ecb7431af376e585b58df6f10235a7" name="aa5ecb7431af376e585b58df6f10235a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ecb7431af376e585b58df6f10235a7">&#9670;&#160;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare member data </p>
<dl class="section remark"><dt>Remarks</dt><dd>returns false if any member data are NaN </dd></dl>

</div>
</div>
<a id="ac96076229fbc5ad8d484428bee92b153" name="ac96076229fbc5ad8d484428bee92b153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96076229fbc5ad8d484428bee92b153">&#9670;&#160;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a>&#160;</td>
          <td class="paramname"><em>polygon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a>&#160;</td>
          <td class="paramname"><em>polygon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff vertex lists are identical, but false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a> has size 0 </p>
<dl class="section remark"><dt>Remarks</dt><dd>returns false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices">Polygon</a> has size 0 </dd>
<dd>
O(n) time complexity </dd></dl>

</div>
</div>
<a id="a7058b06639d3231e9430b7946c83390c" name="a7058b06639d3231e9430b7946c83390c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7058b06639d3231e9430b7946c83390c">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare lexicographic order of points </p>
<p >For Points p1 and p2, p1 &lt; p2 iff either p1.x() &lt; p2.x() or p1.x()==p2.x() and p1.y()&lt;p2.y(). False if any member data have not been assigned (numbers). </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a line parallel to one of the axes </dd></dl>

</div>
</div>
<a id="ac507aa8babe8577aa58a90fff0f3a1ed" name="ac507aa8babe8577aa58a90fff0f3a1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac507aa8babe8577aa58a90fff0f3a1ed">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare according to polar lexicographic order (smaller bearing, then smaller range) </p>
<p >false if any member data have not been assigned (numbers) </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a radial line </dd></dl>

</div>
</div>
<a id="aab0266fe487ca62b657cca017ba5e3b2" name="aab0266fe487ca62b657cca017ba5e3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0266fe487ca62b657cca017ba5e3b2">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare lexicographic order of points </p>
<p >For Points p1 and p2, p1 &lt; p2 iff either p1.x() &lt; p2.x() or p1.x()==p2.x() and p1.y()&lt;p2.y(). False if any member data have not been assigned (numbers). </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a line parallel to one of the axes </dd></dl>

</div>
</div>
<a id="ac87a4a15e00ffdfe72fbb2b56d4020a3" name="ac87a4a15e00ffdfe72fbb2b56d4020a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87a4a15e00ffdfe72fbb2b56d4020a3">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare according to polar lexicographic order (smaller bearing, then smaller range) </p>
<p >false if any member data have not been assigned (numbers) </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a radial line </dd></dl>

</div>
</div>
<a id="ae83e7a472af84e482d88ab9963401fcd" name="ae83e7a472af84e482d88ab9963401fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83e7a472af84e482d88ab9963401fcd">&#9670;&#160;</a></span>uniform_random_sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::uniform_random_sample </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a uniform random sample from an (inclusive) interval on the real line </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_bound</td><td>lower bound of the real interval </td></tr>
    <tr><td class="paramname">upper_bound</td><td>upper bound of the real interval </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>lower_bound</em> &lt;= <em>upper_bound</em> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a random sample from a uniform probability distribution on the real interval [<em>lower_bound</em>, <em>upper_bound</em>] </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Uses the Standard Library's rand() function. rand() should be seeded (only necessary once at the beginning of the program) using the command std::srand( std::time( NULL ) ); rand(); </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>performance degrades as upper_bound - lower_bound approaches RAND_MAX. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7ac10ccfdc14c4c8093b7528c1fd7fd5" name="a7ac10ccfdc14c4c8093b7528c1fd7fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac10ccfdc14c4c8093b7528c1fd7fd5">&#9670;&#160;</a></span>FIOS_PRECISION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int VisiLibity::FIOS_PRECISION = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>floating-point display precision. </p>
<p >This is the default precision with which floating point numbers are displayed or written to files for classes with a write_to_file() method. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
